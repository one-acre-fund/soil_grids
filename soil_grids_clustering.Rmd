---
author: '[Matt Lowes](mailto:email@oneacrefund.org)'
date: '`r format(Sys.time(), "%B %d, %Y")`'
output:
  html_notebook:
    number_sections: yes
    code_folding: hide
    theme: flatly
    toc: yes
    toc_depth: 6
    toc_float: yes
    css: static/styles.css
---
<title>Title</title>
```{r setup, include=FALSE}
#### set up
## clear environment and console
rm(list = ls())
cat("\014")

## set up some global options
# always set stringsAsFactors = F when loading data
options(stringsAsFactors=FALSE)

# show the code
knitr::opts_chunk$set(echo = TRUE)

# define all knitr tables to be html format
options(knitr.table.format = 'html')

# change code chunk default to not show warnings or messages
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

## load libraries
# dplyr and tibble are for working with tables
# reshape is for easy table transformation
# knitr is to make pretty tables at the end
# ggplot2 is for making graphs
# readxl is for reading in Excel files
# MASS is for running boxcox tests
# gridExtra is for arranging plots
# cowplot is for adding subtitles to plots
# robustbase is to run robust regressions to compensate for outliers
# car is for performing logit transformations
libs <- c("tidyverse", "knitr", "readxl", "curl", "raster", "rgdal")
lapply(libs, require, character.only = T, quietly = T, warn.conflicts = F)

#### define helpful functions
# define function to adjust table widths
html_table_width <- function(kable_output, width) {
  width_html <- paste0(paste0('<col width="', width, '">'), collapse = "\n")
  sub("<table>", paste0("<table>\n", width_html), kable_output)
}
options(readr.show_progress = FALSE)
select <- dplyr::select
```

# Objectives

We're trying to make soil classes for 1AF Kenya to inform the placement of on-farm nutrient omission trials. This analysis accesses data from the [AfSIS soil grids project](http://data.isric.org/geonetwork/srv/eng/catalog.search#/home), combines them into a feature set and identifies clusters across sampling units to inform trial placement. 

# Data

Most of the data have been zipped. I'm just goint to manually unzip it to simplify the process. Here's the complete list of the data I've tried to access from the online repository:

* Africa SoilGrids pH (predictions for pH H2O (10) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_PHIHOX_T__M_sd1_250m.tif**
* Africa SoilGrids organic C (predictions for SOC (g/kg) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_ORCDRC_T__M_sd1_250m.tif**
* Africa SoilGrids total N 2017 (predictions for TN (mg/kg) for 0-30 cm   
    + **af250m_nutrient_n_m_agg30cm.tif**
* Africa SoilGrids texture (textural classes derived from predictions for sand, silt & clay for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_TEXMHT_T__M_sd1_250m.tif**
* Africa SoilGrids root zone texture (textural classes derived from predictions for sand, silt & clay for 0-30 cm (also available for the rootable depth) with a resolution of 1km 
    + **af_agg_30cm_TEXCLSS__M_1km.tif**
* Africa SoilGrids sand (predictions for sand content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_SNDPPT_T__M_sd1_250m.tif**
* Africa SoilGrids silt (predictions for silt content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_SLTPPT_T__M_sd1_250m.tif**
* Africa SoilGrids clay (predictions for clay content (w%) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_CLYPPT_T__M_sd1_250m.tif**
* Africa SoilGrids CEC (predictions for CEC (cmolc/kg) for individual depth intervals (0-5, 5-15, 15-30 cm); make weighted average 
    + **af_CEC_T__M_sd1_250m.tif**
* Africa SoilGrids P (predictions for available P, according to Mehlich 3 (mg/100kg; thus divide by 100 for ppm) for 0-30 cm 
* Africa SoilGrids P (predictions for total P (mg/kg) for 0-30 cm         
    + **af250m_nutrient_p_t_m_agg30cm.tif**
* Africa SoilGrids root zone coarse (predictions for coarse fragments content (v%) for 0-30 cm (also for rootable depth) at 1km resolution 
    + **af_agg_30cm_CRFVOL__M_1km.tif**
* Africa SoilGrids root zone (derived maps for rootable depth (cm), and other properties aggregated over 0-30 cm as well as over root zone depth, at 1 km resolution 
    + **af_ERZD__M_1km.tif**

And Johan clarified that the weights refer to amount of soil depth:
the weights refer to the depth intervals :

* 0-5 = 5/30 - this refers to `sd1` in the file names
* 5-15 = 10/30 - this refers to `sd2` in the file names
* 15-30 = 15/30 - this refers to `sd3` in the file names

```{r}
firstWeight <- 5/30
secondWeight <- 10/30
thirdWeight <- 15/30

weightList <- list(firstWeight, secondWeight, thirdWeight)
```


```{r}
rawDir <- normalizePath(file.path("..", "soil_grids_raw_data"))

dataDir <- normalizePath(file.path("..", "soil_grids_data"))

tifFiles <- paste0(rawDir, "/", list.files(rawDir, pattern = ".tif$"))

```

I want to import all of these rasters but it's important that they be clearly grouped so that I can create weighted layers for all N, C, P, etc. before combining them into a single data frame. The following functions will import the selected rasters then perform the necessary calculations to prepare that soil nutrient feature for the end analysis.

The overall soil rasters are too big to do the calculations first (even if I'm doing them as efficiently as possible which I may not be). Therefore I first need to trim the larger raster down to just Kenya before calculating the weights and averages.

## Kenya boundaries

```{r}
if(!file.exists(paste0(dataDir, "/GADM_2.8_KEN_adm2.rds"))){
  keBoundaries <- getData("GADM", country='KE', level=2, path = dataDir) 
} else {
  keBoundaries <- readRDS(paste0(dataDir, "/GADM_2.8_KEN_adm2.rds"))
}

## transform the shape file to the correct CRS system
keBoundaries <- spTransform(keBoundaries, CRS("+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))


# I additionally want to subset this down to just western Kenya because it's too computationally intentsive to run these calculations for other areas. I'm going to subset the shape file to just western Kenya and the plot it to confirm I've done it correctly.

# from Name 1
westernAreas <- c("Bungoma", "Busia", "Elgeyo-Marakwet", "Homa Bay", "Kakamega", "Kericho", "Kisii", "Kisumu", "Migori", "Nyamira", "Siaya", "Vihiga")

westernMap <- keBoundaries[tolower(westernAreas) %in% tolower(keBoundaries$NAME_1),]

plot(westernMap)
```

```{r eval=FALSE, include=FALSE}
plot(keBoundaries)
```


## Applying weights

It's not going to be very elegant but I'm going to manually apply the weights to the soil layers because I can't figure out a more efficient way to do this. Ultimately I probably want that in a separate data preparation script but for the time being I'll just have it save a final file that I won't refresh unless I need to. Here's a [helpful reference](https://gis.stackexchange.com/questions/61243/clipping-a-raster-in-r).

```{r}
tifFinder <- function(input){
  # finds the right layers from the full set of input data, tifFiles
  #outputs list of those files.
  tifFiles[grep(input, tifFiles)]
}


importRasterAsList <- function(listInput){
  # import the relevant files for the soil layer
  # outputs a raster list
  rasterFile = lapply(listInput, function(x) raster(x))
}

addWeights <- function(rasterList, weightList){
  
  # confirm that this approach gives the same result as doing it manually.
  # confirmed that this is leading to same result!
  
  # make sure it's in order!
    r = Map("*", rasterList, weightList)
    return(r)
  
}


```

```{r}
forceUpdate <- FALSE
  
  # I can't hold all the raw data in memory so I'll run these one at a time and then only keep the analyzed results on the hd.

# ph but with functions
if(!file.exists(paste(dataDir, "output", "pH_weighted_layer.tif", sep = "/")) | forceUpdate){
  print("tried")
  pHLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_PHIHOX_T__M")), weightList)))
  
  writeRaster(pHLayer, file = paste(outputDir, "output", "pH_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  pHLayer <- raster(paste(dataDir, "output", "pH_weighted_layer.tif", sep = "/"))
}

# carbon
if(!file.exists(paste(dataDir, "output", "carbon_weighted_layer.tif", sep = "/")) | forceUpdate){
  carbonLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_ORCDRC_T__M")), weightList)))
  
  writeRaster(carbonLayer, file = paste(dataDir, "output", "carbon_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  carbonLayer <- raster(paste(dataDir, "output", "carbon_weighted_layer.tif", sep = "/"))
}

# texture
if(!file.exists(paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/")) | forceUpdate){
  textureLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_TEXMHT_T__M")), weightList)))
  
  writeRaster(textureLayer, file = paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  textureLayer <- raster(paste(dataDir, "output", "texture_weighted_layer.tif", sep = "/"))
}

# sand content
if(!file.exists(paste(dataDir, "output", "sand_weighted_layer.tif", sep = "/")) | forceUpdate){
  sandLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_SNDPPT_T__M")), weightList)))
  
  writeRaster(sandLayer, file = paste(dataDir, "output", "sand_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  sandLayer <- raster(paste(dataDir, "output", "sand_weighted_layer.tif", sep = "/"))
}
# silt content
if(!file.exists(paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/")) | forceUpdate){
  siltLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_SLTPPT_T__M")), weightList)))
  
  writeRaster(siltLayer, file = paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  siltLayer <- raster(paste(dataDir, "output", "silt_weighted_layer.tif", sep = "/"))
}

# clay content
if(!file.exists(paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/")) | forceUpdate){
  clayLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_CLYPPT_T__M")), weightList)))
  
  writeRaster(clayLayer, file = paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  clayLayer <- raster(paste(dataDir, "output", "clay_weighted_layer.tif", sep = "/"))
}

# CEC
if(!file.exists(paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/")) | forceUpdate){
  cecLayer <- mean(stack(addWeights(importRasterAsList(tifFinder("af_CEC_T__M")), weightList)))
  
  writeRaster(cecLayer, file = paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  cecLayer <- raster(paste(dataDir, "output", "cec_weighted_layer.tif", sep = "/"))
}
  
```

## Importing other layers

This summary repeats content from above:

* Africa SoilGrids root zone texture (textural classes derived from predictions for sand, silt & clay for 0-30 cm (also available for the rootable depth) with a resolution of 1km 
    + **af_agg_30cm_TEXCLSS__M_1km.tif**
* Africa SoilGrids P (predictions for available P, according to Mehlich 3 (mg/100kg; thus divide by 100 for ppm) for 0-30 cm 
* Africa SoilGrids P (predictions for total P (mg/kg) for 0-30 cm         
    + **af250m_nutrient_p_t_m_agg30cm.tif**
* Africa SoilGrids root zone coarse (predictions for coarse fragments content (v%) for 0-30 cm (also for rootable depth) at 1km resolution 
    + **af_agg_30cm_CRFVOL__M_1km.tif**
* Africa SoilGrids root zone (derived maps for rootable depth (cm), and other properties aggregated over 0-30 cm as well as over root zone depth, at 1 km resolution 
    + **af_ERZD__M_1km.tif**
    
    
I'm importing these directly because it's not computationally intensive to do so.

```{r eval=FALSE, include=FALSE}
if(!file.exist(paste(dataDir, "output", "phosphorous_layer_projected.tif", sep = "/")) | forceUpdate){
  phosLayer <- importRasterAsList(tifFinder("af250m_nutrient_p_t_m_agg30cm.tif"))[[1]]
  phosLayer <- projectRaster(phosLayer, crs = "+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")
  writeRaster(phosLayer, file = paste(dataDir, "output", "phosphorous_layer.tif", sep = "/"), format="GTiff", overwrite=TRUE)
} else {
  phosLayer <- raster(paste(dataDir, "output", "phosphorous_layer_projected.tif", sep = "/"))
}
```


```{r}
zoneTextureLayer <- importRasterAsList(tifFinder("af_agg_30cm_TEXCLSS__M_1km.tif"))[[1]]

zoneCoarseLayer <- importRasterAsList(tifFinder("af_agg_30cm_CRFVOL__M_1km.tif"))[[1]]

zoneLayer <- importRasterAsList(tifFinder("af_ERZD__M_1km.tif"))[[1]]
```

## Stacking data

Align the extent of the weighted rasters with the other rasters so I can combine them into a single stack before making the clusters.

**Crop the other rasters to the extent of the weighted rasters.**

```{r}
weightedLayers <- c(pHLayer, carbonLayer, textureLayer, sandLayer, clayLayer, cecLayer)

unweightedLayers <- c(zoneTextureLayer, zoneCoarseLayer, zoneLayer)

# lapply(weightedLayers, function(x) extent(x))
# 
# lapply(unweightedLayers, function(x) extent(x))

#phosLayer # this is in a different projection! convert!
```

And then check that the extent of the phosphorous layer is the same as the ohter layers so they can all fit in one stack together. **I'm currently excluding the phosphorous layer as it was taking forever to reproject in the right projection. Moving on!

An option for a future update is to utilize a package like clusteR to run the re-projection arcoss multiple clusters. But not today!

```{r}
soilStack <- stack(weightedLayers, unweightedLayer)
```


## Cropping data

`Crop` extent of the raster and then `mask` raster to fit the outlines of Kenya. Hopefully this doesn't take too long? Not too long! This step is necessary or else the raster is too big for the later steps. 

```{r}
soilCrop <- crop(soilStack, extent(keBoundaries))

soilMask <- mask(soilCrop, keBoundaries)
```

# Clustering Code

The main steps here will be:

* Convert the raster data to a data frame so that I can create the clusters
* Use the existing k-means code to create clusters
* Identify the tipping point in the graph

This [website details the process of converting raster to data frame](https://www.rdocumentation.org/packages/raster/versions/2.8-4/topics/as.data.frame)

And then per Step's requests:

* How we should stratify our sampling across those clusters with our 9 trial officers
* A list of site options for each trial officer. Site options need to be:
    + away from cluster boundaries (e.g. create a shape file of each cluster, then trim 10% off margins)
    + spread out as much as possible within the cluster (if we are assigning >1 trial officer to any cluster)
    + ideally close to 2 other sitesâ€¦if this is too much, if we have districts which are all well within any cluster, I think that might be enough for Kenya PI to work with for now.

This converts the grids into points but in some way I don't really care what each point is called. But I need a way to connet each point back to something interpretable.

```{r}
soilDf <- raster::as.data.frame(soilMask, xy = TRUE, na.rm = TRUE)
```

# Clustering analysis

```{r}
numClusters <- 4:20

runKMeans <- function(dat, datCols, gps=TRUE, completeVar, numClusters=2:8) {
  # this function executes k-means clustering. I'm modifying it from the original code in the global_aez and country_aez R files to work with the raster data. This just works with the soil data in raster format. It might be better to functionize the input selection more but I'm just going to hardcode it for now.
  # output - k means cluster assignments in list form
  
  kClusts <- lapply(numClusters, FUN=function(k) {
    datA = dat[,c(datCols)]
    datA = datA[!is.na(datA[,completeVar]),]
    scaled <- scale(datA)
    set.seed(2017201616)
    kmeans(scaled, centers=k, nstart=50, iter.max=100)
  })
  return(kClusts)
}

```

```{r}
soilCols <- names(soilDf)[grep("layer", names(soilDf))]

soilClusters <- runKMeans(d, c(soilCols), gps=FALSE, completeVar = "pH_weighted_layer", numClusters)

plot(numClusters, lapply(soilClusters, FUN=function(x) { sum(x$withinss) }),   
     type="b", ylab="average within cluster sum of square error",
     main="Clustering weather and altitude at (basically) site level")
```

# Output

# Appendix
